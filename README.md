# iFlow CLI SDK for Rust

A powerful Rust SDK for interacting with iFlow using the Agent Communication Protocol (ACP). This SDK provides both simple query functions and full bidirectional client for complex interactions.

[![codecov](https://codecov.io/gh/vibe-ideas/iflow-cli-sdk-rust/graph/badge.svg?token=BvIMyyZx1n)](https://codecov.io/gh/vibe-ideas/iflow-cli-sdk-rust) | [![DeepWiki](https://img.shields.io/badge/DeepWiki-vibe--ideas%2Fiflow--cli--sdk--rust-blue.svg?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAyCAYAAAAnWDnqAAAAAXNSR0IArs4c6QAAA05JREFUaEPtmUtyEzEQhtWTQyQLHNak2AB7ZnyXZMEjXMGeK/AIi+QuHrMnbChYY7MIh8g01fJoopFb0uhhEqqcbWTp06/uv1saEDv4O3n3dV60RfP947Mm9/SQc0ICFQgzfc4CYZoTPAswgSJCCUJUnAAoRHOAUOcATwbmVLWdGoH//PB8mnKqScAhsD0kYP3j/Yt5LPQe2KvcXmGvRHcDnpxfL2zOYJ1mFwrryWTz0advv1Ut4CJgf5uhDuDj5eUcAUoahrdY/56ebRWeraTjMt/00Sh3UDtjgHtQNHwcRGOC98BJEAEymycmYcWwOprTgcB6VZ5JK5TAJ+fXGLBm3FDAmn6oPPjR4rKCAoJCal2eAiQp2x0vxTPB3ALO2CRkwmDy5WohzBDwSEFKRwPbknEggCPB/imwrycgxX2NzoMCHhPkDwqYMr9tRcP5qNrMZHkVnOjRMWwLCcr8ohBVb1OMjxLwGCvjTikrsBOiA6fNyCrm8V1rP93iVPpwaE+gO0SsWmPiXB+jikdf6SizrT5qKasx5j8ABbHpFTx+vFXp9EnYQmLx02h1QTTrl6eDqxLnGjporxl3NL3agEvXdT0WmEost648sQOYAeJS9Q7bfUVoMGnjo4AZdUMQku50McDcMWcBPvr0SzbTAFDfvJqwLzgxwATnCgnp4wDl6Aa+Ax283gghmj+vj7feE2KBBRMW3FzOpLOADl0Isb5587h/U4gGvkt5v60Z1VLG8BhYjbzRwyQZemwAd6cCR5/XFWLYZRIMpX39AR0tjaGGiGzLVyhse5C9RKC6ai42ppWPKiBagOvaYk8lO7DajerabOZP46Lby5wKjw1HCRx7p9sVMOWGzb/vA1hwiWc6jm3MvQDTogQkiqIhJV0nBQBTU+3okKCFDy9WwferkHjtxib7t3xIUQtHxnIwtx4mpg26/HfwVNVDb4oI9RHmx5WGelRVlrtiw43zboCLaxv46AZeB3IlTkwouebTr1y2NjSpHz68WNFjHvupy3q8TFn3Hos2IAk4Ju5dCo8B3wP7VPr/FGaKiG+T+v+TQqIrOqMTL1VdWV1DdmcbO8KXBz6esmYWYKPwDL5b5FA1a0hwapHiom0r/cKaoqr+27/XcrS5UwSMbQAAAABJRU5ErkJggg==)](https://deepwiki.com/vibe-ideas/iflow-cli-sdk-rust)
<!-- DeepWiki badge generated by https://deepwiki.ryoppippi.com/ -->

## Features

- ðŸš€ **Automatic Process Management** - SDK automatically starts and manages iFlow process
- ðŸ”Œ **Stdio Communication** - Communicate with iFlow via stdio
- ðŸ”Œ **WebSocket Communication** - Communicate with iFlow via WebSocket for better performance and reliability
- ðŸ”„ **Bidirectional Communication** - Real-time streaming messages and responses
- ðŸ› ï¸ **Tool Call Management** - Fine-grained permission control for tool execution
- ðŸ“‹ **Task Planning** - Receive and process structured task plans
- ðŸ” **Raw Data Access** - Debug and inspect protocol-level messages
- âš¡ **Async/Await Support** - Modern async Rust with full type safety

## TODO

- [ ] ðŸ¤– **Sub-agent Support** - Track and manage multiple AI agents via `agent_id`

[ROADMAP.md](ROADMAP.md)

## Installation

Add this to your `Cargo.toml`:

```toml
[dependencies]
iflow-cli-sdk-rust = "0.1.0"
```

Or install directly from the repository:

```bash
cargo add --git https://github.com/vibe-ideas/iflow-cli-sdk-rust
```

## Quick Start

### Simple Query

```rust
use iflow_cli_sdk_rust::query;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let response = query("What is 2 + 2?").await?;
    println!("{}", response); // "4"
    Ok(())
}
```

### Simple Query with Custom Configuration

```rust
use iflow_cli_sdk_rust::{query_with_config, IFlowOptions};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let options = IFlowOptions::new()
        .with_timeout(60.0);  // 60 second timeout
        
    let response = query_with_config("What is 2 + 2?", options).await?;
    println!("{}", response); // "4"
    Ok(())
}

### Interactive Session

```rust
use iflow_cli_sdk_rust::{IFlowClient, IFlowOptions, Message};
use futures::stream::StreamExt;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let options = IFlowOptions::new()
        .with_auto_start_process(true);
    
    let mut client = IFlowClient::new(Some(options));
    client.connect().await?;
    
    client.send_message("Hello, iFlow!", None).await?;
    
    let mut message_stream = client.messages();
    while let Some(message) = message_stream.next().await {
        match message {
            Message::Assistant { content } => {
                print!("{}", content);
                std::io::stdout().flush()?;
            }
            Message::TaskFinish { .. } => {
                break;
            }
            _ => {
                // Handle other message types
            }
        }
    }
    
    client.disconnect().await?;
    Ok(())
}
```

### Streaming Responses

```rust
use iflow_cli_sdk_rust::query_stream;
use futures::stream::StreamExt;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut stream = query_stream("Tell me a story").await?;
    
    while let Some(chunk) = stream.next().await {
        print!("{}", chunk);
        std::io::stdout().flush()?;
    }
    
    Ok(())
}
```

### Streaming Responses with Custom Configuration

```rust
use iflow_cli_sdk_rust::{query_stream_with_config, IFlowOptions};
use futures::stream::StreamExt;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let options = IFlowOptions::new()
        .with_timeout(60.0);  // 60 second timeout
        
    let mut stream = query_stream_with_config("Tell me a story", options).await?;
    
    while let Some(chunk) = stream.next().await {
        print!("{}", chunk);
        std::io::stdout().flush()?;
    }
    
    Ok(())
}

## Configuration

### Client Options

```rust
use iflow_cli_sdk_rust::IFlowOptions;

let options = IFlowOptions::new()
    .with_timeout(60.0)
    .with_file_access(true)
    .with_auto_start_process(true);
```

### WebSocket Communication

The SDK supports WebSocket communication with iFlow for better performance and reliability. To use WebSocket, specify the WebSocket configuration in the options:

```rust
use iflow_cli_sdk_rust::{IFlowOptions, types::WebSocketConfig};

// Simple configuration with default reconnect settings
let options = IFlowOptions::new()
    .with_websocket_config(WebSocketConfig::new("ws://localhost:8090/acp?peer=iflow".to_string()));

// Or use the default configuration
let options = IFlowOptions::new()
    .with_websocket_config(WebSocketConfig::default());

// Or configure with custom reconnect settings
let options = IFlowOptions::new()
    .with_websocket_config(WebSocketConfig::with_reconnect_settings(
        "ws://localhost:8090/acp?peer=iflow".to_string(),
        5,  // reconnect attempts
        std::time::Duration::from_secs(10)  // reconnect interval
    ));

// In auto-start mode, you can omit the URL entirely
let options = IFlowOptions::new()
    .with_websocket_config(WebSocketConfig::auto_start());

// Or configure auto-start mode with custom reconnect settings
let options = IFlowOptions::new()
    .with_websocket_config(WebSocketConfig::auto_start_with_reconnect_settings(
        5,  // reconnect attempts
        std::time::Duration::from_secs(10)  // reconnect interval
    ));
```

If you enable auto-start process with a WebSocket URL pointing to localhost, the SDK will automatically start the iFlow process if it's not already running. In auto-start mode, you can omit the URL entirely and let the SDK generate it automatically.

## Message Types

The SDK handles various message types from iFlow:

- `Message::Assistant { content }` - AI assistant responses
- `Message::ToolCall { id, name, status }` - Tool execution requests
- `Message::Plan { entries }` - Structured task plans
- `Message::TaskFinish { reason }` - Task completion signals
- `Message::Error { code, message }` - Error notifications
- `Message::User { content }` - User message echoes

## Examples

Run the examples:

```bash
# Simple query example
cargo run --example query

# Interactive client example
cargo run --example basic_client

# Test response handling
cargo run --example test_response

# Explore API capabilities
cargo run --example explore_api

# Test real-time message streaming
cargo run --example test_stream

# Test real-time performance
cargo run --example test_realtime

# Logging example
cargo run --example logging_example
```

## Architecture

The SDK is organized into several modules:

- `client` - Main IFlowClient implementation with stdio communication
- `types` - Type definitions and message structures
- `process_manager` - iFlow process lifecycle management
- `query` - Convenience functions for simple queries
- `error` - Error types and handling
- `logger` - Message logging functionality

## Requirements

- Rust 1.70+
- iFlow CLI installed with `--experimental-acp` support (or use auto-start feature)

## Development

### Building

```bash
cargo build
```

### Testing

```bash
cargo test

# Run specific test suites
cargo test --test websocket_config_tests
cargo test --test websocket_integration_tests

# e2e tests
cargo test --test e2e_tests -- --nocapture
```

### Running with logging

```bash
RUST_LOG=info cargo run --example basic_client
```

## License

MIT License - see LICENSE file for details.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.
